# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T02:03:14+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Path, Query, Request
from pydantic import conint

from models import (
    About,
    Alt,
    ChangeList,
    Channel,
    Comment,
    CommentList,
    Corpus,
    Drive,
    DriveList,
    File,
    FileList,
    GeneratedIds,
    LabelList,
    ModifyLabelsRequest,
    ModifyLabelsResponse,
    Permission,
    PermissionList,
    Reply,
    ReplyList,
    Revision,
    RevisionList,
    StartPageToken,
    TeamDrive,
    TeamDriveList,
)

app = MCPProxy(
    contact={'name': 'Google', 'url': 'https://google.com', 'x-twitter': 'youtube'},
    description='Manages files in Drive including uploading, downloading, searching, detecting changes, and updating sharing permissions.',
    license={
        'name': 'Creative Commons Attribution 3.0',
        'url': 'http://creativecommons.org/licenses/by/3.0/',
    },
    termsOfService='https://developers.google.com/terms/',
    title='Drive API',
    version='v3',
    servers=[{'url': 'https://www.googleapis.com/drive/v3'}],
)


@app.get(
    '/about',
    description=""" Gets information about the user, the user's Drive, and system capabilities. """,
    tags=['drive_management', 'drive_permission_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_about_get(
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/changes',
    description=""" Lists the changes for a user or shared drive. """,
    tags=[
        'drive_management',
        'drive_file_operations',
        'drive_permission_management',
        'team_drive_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_changes_list(
    page_token: str = Query(..., alias='pageToken'),
    drive_id: Optional[str] = Query(None, alias='driveId'),
    include_corpus_removals: Optional[bool] = Query(
        None, alias='includeCorpusRemovals'
    ),
    include_items_from_all_drives: Optional[bool] = Query(
        None, alias='includeItemsFromAllDrives'
    ),
    include_labels: Optional[str] = Query(None, alias='includeLabels'),
    include_permissions_for_view: Optional[str] = Query(
        None, alias='includePermissionsForView'
    ),
    include_removed: Optional[bool] = Query(None, alias='includeRemoved'),
    include_team_drive_items: Optional[bool] = Query(
        None, alias='includeTeamDriveItems'
    ),
    page_size: Optional[conint(ge=1, le=1000)] = Query(None, alias='pageSize'),
    restrict_to_my_drive: Optional[bool] = Query(None, alias='restrictToMyDrive'),
    spaces: Optional[str] = None,
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    team_drive_id: Optional[str] = Query(None, alias='teamDriveId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/changes/startPageToken',
    description=""" Gets the starting pageToken for listing future changes. """,
    tags=['team_drive_management', 'drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_changes_get_start_page_token(
    drive_id: Optional[str] = Query(None, alias='driveId'),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    team_drive_id: Optional[str] = Query(None, alias='teamDriveId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/changes/watch',
    description=""" Subscribes to changes for a user. To use this method, you must include the pageToken query parameter. """,
    tags=['drive_management', 'team_drive_management', 'drive_permission_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_changes_watch(
    page_token: str = Query(..., alias='pageToken'),
    drive_id: Optional[str] = Query(None, alias='driveId'),
    include_corpus_removals: Optional[bool] = Query(
        None, alias='includeCorpusRemovals'
    ),
    include_items_from_all_drives: Optional[bool] = Query(
        None, alias='includeItemsFromAllDrives'
    ),
    include_labels: Optional[str] = Query(None, alias='includeLabels'),
    include_permissions_for_view: Optional[str] = Query(
        None, alias='includePermissionsForView'
    ),
    include_removed: Optional[bool] = Query(None, alias='includeRemoved'),
    include_team_drive_items: Optional[bool] = Query(
        None, alias='includeTeamDriveItems'
    ),
    page_size: Optional[conint(ge=1, le=1000)] = Query(None, alias='pageSize'),
    restrict_to_my_drive: Optional[bool] = Query(None, alias='restrictToMyDrive'),
    spaces: Optional[str] = None,
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    team_drive_id: Optional[str] = Query(None, alias='teamDriveId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/channels/stop',
    description=""" Stop watching resources through this channel """,
    tags=['drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_channels_stop(
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/drives',
    description=""" Lists the user's shared drives. """,
    tags=[
        'drive_management',
        'drive_file_operations',
        'drive_change_tracking',
        'drive_permission_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_drives_list(
    page_size: Optional[conint(ge=1, le=100)] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    q: Optional[str] = None,
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/drives',
    description=""" Creates a shared drive. """,
    tags=['drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_drives_create(
    request_id: str = Query(..., alias='requestId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Drive = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/drives/{driveId}',
    description=""" Permanently deletes a shared drive for which the user is an organizer. The shared drive cannot contain any untrashed items. """,
    tags=['drive_management', 'team_drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_drives_delete(
    drive_id: str = Path(..., alias='driveId'),
    allow_item_deletion: Optional[bool] = Query(None, alias='allowItemDeletion'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/drives/{driveId}',
    description=""" Gets a shared drive's metadata by ID. """,
    tags=['drive_management', 'team_drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_drives_get(
    drive_id: str = Path(..., alias='driveId'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/drives/{driveId}',
    description=""" Updates the metadata for a shared drive. """,
    tags=['drive_management', 'team_drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_drives_update(
    drive_id: str = Path(..., alias='driveId'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Drive = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/drives/{driveId}/hide',
    description=""" Hides a shared drive from the default view. """,
    tags=['drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_drives_hide(
    drive_id: str = Path(..., alias='driveId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/drives/{driveId}/unhide',
    description=""" Restores a shared drive to the default view. """,
    tags=['drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_drives_unhide(
    drive_id: str = Path(..., alias='driveId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files',
    description=""" Lists or searches files. """,
    tags=['drive_management', 'team_drive_management', 'drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_list(
    corpora: Optional[str] = None,
    corpus: Optional[Corpus] = None,
    drive_id: Optional[str] = Query(None, alias='driveId'),
    include_items_from_all_drives: Optional[bool] = Query(
        None, alias='includeItemsFromAllDrives'
    ),
    include_labels: Optional[str] = Query(None, alias='includeLabels'),
    include_permissions_for_view: Optional[str] = Query(
        None, alias='includePermissionsForView'
    ),
    include_team_drive_items: Optional[bool] = Query(
        None, alias='includeTeamDriveItems'
    ),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_size: Optional[conint(ge=1, le=1000)] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    q: Optional[str] = None,
    spaces: Optional[str] = None,
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    team_drive_id: Optional[str] = Query(None, alias='teamDriveId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files',
    description=""" Creates a file. """,
    tags=[
        'drive_management',
        'drive_file_operations',
        'drive_permission_management',
        'drive_revision_tracking',
        'team_drive_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_create(
    enforce_single_parent: Optional[bool] = Query(None, alias='enforceSingleParent'),
    ignore_default_visibility: Optional[bool] = Query(
        None, alias='ignoreDefaultVisibility'
    ),
    include_labels: Optional[str] = Query(None, alias='includeLabels'),
    include_permissions_for_view: Optional[str] = Query(
        None, alias='includePermissionsForView'
    ),
    keep_revision_forever: Optional[bool] = Query(None, alias='keepRevisionForever'),
    ocr_language: Optional[str] = Query(None, alias='ocrLanguage'),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    use_content_as_indexable_text: Optional[bool] = Query(
        None, alias='useContentAsIndexableText'
    ),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/generateIds',
    description=""" Generates a set of file IDs which can be provided in create or copy requests. """,
    tags=['drive_management', 'drive_file_operations', 'drive_permission_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_generate_ids(
    count: Optional[conint(ge=1, le=1000)] = None,
    space: Optional[str] = None,
    type: Optional[str] = None,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/trash',
    description=""" Permanently deletes all of the user's trashed files. """,
    tags=['drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_empty_trash(
    drive_id: Optional[str] = Query(None, alias='driveId'),
    enforce_single_parent: Optional[bool] = Query(None, alias='enforceSingleParent'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/{fileId}',
    description=""" Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive the user must be an organizer on the parent. If the target is a folder, all descendants owned by the user are also deleted. """,
    tags=['drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_delete(
    file_id: str = Path(..., alias='fileId'),
    enforce_single_parent: Optional[bool] = Query(None, alias='enforceSingleParent'),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}',
    description=""" Gets a file's metadata or content by ID. """,
    tags=[
        'drive_file_operations',
        'drive_permission_management',
        'team_drive_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_get(
    file_id: str = Path(..., alias='fileId'),
    acknowledge_abuse: Optional[bool] = Query(None, alias='acknowledgeAbuse'),
    include_labels: Optional[str] = Query(None, alias='includeLabels'),
    include_permissions_for_view: Optional[str] = Query(
        None, alias='includePermissionsForView'
    ),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/files/{fileId}',
    description=""" Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics. """,
    tags=['drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_update(
    file_id: str = Path(..., alias='fileId'),
    add_parents: Optional[str] = Query(None, alias='addParents'),
    enforce_single_parent: Optional[bool] = Query(None, alias='enforceSingleParent'),
    include_labels: Optional[str] = Query(None, alias='includeLabels'),
    include_permissions_for_view: Optional[str] = Query(
        None, alias='includePermissionsForView'
    ),
    keep_revision_forever: Optional[bool] = Query(None, alias='keepRevisionForever'),
    ocr_language: Optional[str] = Query(None, alias='ocrLanguage'),
    remove_parents: Optional[str] = Query(None, alias='removeParents'),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    use_content_as_indexable_text: Optional[bool] = Query(
        None, alias='useContentAsIndexableText'
    ),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/comments',
    description=""" Lists a file's comments. """,
    tags=['drive_file_operations', 'drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_comments_list(
    file_id: str = Path(..., alias='fileId'),
    include_deleted: Optional[bool] = Query(None, alias='includeDeleted'),
    page_size: Optional[conint(ge=1, le=100)] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    start_modified_time: Optional[str] = Query(None, alias='startModifiedTime'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/{fileId}/comments',
    description=""" Creates a comment on a file. """,
    tags=['drive_comments_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_comments_create(
    file_id: str = Path(..., alias='fileId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Comment = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/{fileId}/comments/{commentId}',
    description=""" Deletes a comment. """,
    tags=['drive_comments_management', 'drive_replies_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_comments_delete(
    file_id: str = Path(..., alias='fileId'),
    comment_id: str = Path(..., alias='commentId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/comments/{commentId}',
    description=""" Gets a comment by ID. """,
    tags=['drive_comments_management', 'drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_comments_get(
    file_id: str = Path(..., alias='fileId'),
    comment_id: str = Path(..., alias='commentId'),
    include_deleted: Optional[bool] = Query(None, alias='includeDeleted'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/files/{fileId}/comments/{commentId}',
    description=""" Updates a comment with patch semantics. """,
    tags=['drive_comments_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_comments_update(
    file_id: str = Path(..., alias='fileId'),
    comment_id: str = Path(..., alias='commentId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Comment = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/comments/{commentId}/replies',
    description=""" Lists a comment's replies. """,
    tags=['drive_comments_management', 'drive_replies_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_replies_list(
    file_id: str = Path(..., alias='fileId'),
    comment_id: str = Path(..., alias='commentId'),
    include_deleted: Optional[bool] = Query(None, alias='includeDeleted'),
    page_size: Optional[conint(ge=1, le=100)] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/{fileId}/comments/{commentId}/replies',
    description=""" Creates a reply to a comment. """,
    tags=['drive_replies_management', 'drive_comments_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_replies_create(
    file_id: str = Path(..., alias='fileId'),
    comment_id: str = Path(..., alias='commentId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Reply = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/{fileId}/comments/{commentId}/replies/{replyId}',
    description=""" Deletes a reply. """,
    tags=['drive_comments_management', 'drive_replies_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_replies_delete(
    file_id: str = Path(..., alias='fileId'),
    comment_id: str = Path(..., alias='commentId'),
    reply_id: str = Path(..., alias='replyId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/comments/{commentId}/replies/{replyId}',
    description=""" Gets a reply by ID. """,
    tags=['drive_comments_management', 'drive_replies_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_replies_get(
    file_id: str = Path(..., alias='fileId'),
    comment_id: str = Path(..., alias='commentId'),
    reply_id: str = Path(..., alias='replyId'),
    include_deleted: Optional[bool] = Query(None, alias='includeDeleted'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/files/{fileId}/comments/{commentId}/replies/{replyId}',
    description=""" Updates a reply with patch semantics. """,
    tags=['drive_replies_management', 'drive_comments_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_replies_update(
    file_id: str = Path(..., alias='fileId'),
    comment_id: str = Path(..., alias='commentId'),
    reply_id: str = Path(..., alias='replyId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Reply = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/{fileId}/copy',
    description=""" Creates a copy of a file and applies any requested updates with patch semantics. Folders cannot be copied. """,
    tags=[
        'drive_file_operations',
        'drive_permission_management',
        'drive_revision_tracking',
        'team_drive_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_copy(
    file_id: str = Path(..., alias='fileId'),
    enforce_single_parent: Optional[bool] = Query(None, alias='enforceSingleParent'),
    ignore_default_visibility: Optional[bool] = Query(
        None, alias='ignoreDefaultVisibility'
    ),
    include_labels: Optional[str] = Query(None, alias='includeLabels'),
    include_permissions_for_view: Optional[str] = Query(
        None, alias='includePermissionsForView'
    ),
    keep_revision_forever: Optional[bool] = Query(None, alias='keepRevisionForever'),
    ocr_language: Optional[str] = Query(None, alias='ocrLanguage'),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: File = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/export',
    description=""" Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB. """,
    tags=['drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_export(
    file_id: str = Path(..., alias='fileId'),
    mime_type: str = Query(..., alias='mimeType'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/listLabels',
    description=""" Lists the labels on a file. """,
    tags=['drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_list_labels(
    file_id: str = Path(..., alias='fileId'),
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/{fileId}/modifyLabels',
    description=""" Modifies the set of labels on a file. """,
    tags=['drive_file_operations', 'drive_permission_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_modify_labels(
    file_id: str = Path(..., alias='fileId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ModifyLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/permissions',
    description=""" Lists a file's or shared drive's permissions. """,
    tags=[
        'drive_file_operations',
        'drive_permission_management',
        'team_drive_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_permissions_list(
    file_id: str = Path(..., alias='fileId'),
    include_permissions_for_view: Optional[str] = Query(
        None, alias='includePermissionsForView'
    ),
    page_size: Optional[conint(ge=1, le=100)] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/{fileId}/permissions',
    description=""" Creates a permission for a file or shared drive. For more information on creating permissions, see Share files, folders & drives. """,
    tags=['drive_permission_management', 'drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_permissions_create(
    file_id: str = Path(..., alias='fileId'),
    email_message: Optional[str] = Query(None, alias='emailMessage'),
    enforce_single_parent: Optional[bool] = Query(None, alias='enforceSingleParent'),
    move_to_new_owners_root: Optional[bool] = Query(None, alias='moveToNewOwnersRoot'),
    send_notification_email: Optional[bool] = Query(
        None, alias='sendNotificationEmail'
    ),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    transfer_ownership: Optional[bool] = Query(None, alias='transferOwnership'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Permission = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/{fileId}/permissions/{permissionId}',
    description=""" Deletes a permission. """,
    tags=['drive_permission_management', 'team_drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_permissions_delete(
    file_id: str = Path(..., alias='fileId'),
    permission_id: str = Path(..., alias='permissionId'),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/permissions/{permissionId}',
    description=""" Gets a permission by ID. """,
    tags=['drive_permission_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_permissions_get(
    file_id: str = Path(..., alias='fileId'),
    permission_id: str = Path(..., alias='permissionId'),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/files/{fileId}/permissions/{permissionId}',
    description=""" Updates a permission with patch semantics. """,
    tags=['drive_permission_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_permissions_update(
    file_id: str = Path(..., alias='fileId'),
    permission_id: str = Path(..., alias='permissionId'),
    remove_expiration: Optional[bool] = Query(None, alias='removeExpiration'),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    transfer_ownership: Optional[bool] = Query(None, alias='transferOwnership'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Permission = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/revisions',
    description=""" Lists a file's revisions. """,
    tags=['drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_revisions_list(
    file_id: str = Path(..., alias='fileId'),
    page_size: Optional[conint(ge=1, le=1000)] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/{fileId}/revisions/{revisionId}',
    description=""" Permanently deletes a file version. You can only delete revisions for files with binary content in Google Drive, like images or videos. Revisions for other files, like Google Docs or Sheets, and the last remaining file version can't be deleted. """,
    tags=['drive_revision_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_revisions_delete(
    file_id: str = Path(..., alias='fileId'),
    revision_id: str = Path(..., alias='revisionId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{fileId}/revisions/{revisionId}',
    description=""" Gets a revision's metadata or content by ID. """,
    tags=['drive_revision_tracking', 'drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_revisions_get(
    file_id: str = Path(..., alias='fileId'),
    revision_id: str = Path(..., alias='revisionId'),
    acknowledge_abuse: Optional[bool] = Query(None, alias='acknowledgeAbuse'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/files/{fileId}/revisions/{revisionId}',
    description=""" Updates a revision with patch semantics. """,
    tags=['drive_revision_tracking', 'drive_file_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_revisions_update(
    file_id: str = Path(..., alias='fileId'),
    revision_id: str = Path(..., alias='revisionId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Revision = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/{fileId}/watch',
    description=""" Subscribes to changes to a file. """,
    tags=['drive_file_operations', 'drive_permission_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_files_watch(
    file_id: str = Path(..., alias='fileId'),
    acknowledge_abuse: Optional[bool] = Query(None, alias='acknowledgeAbuse'),
    include_labels: Optional[str] = Query(None, alias='includeLabels'),
    include_permissions_for_view: Optional[str] = Query(
        None, alias='includePermissionsForView'
    ),
    supports_all_drives: Optional[bool] = Query(None, alias='supportsAllDrives'),
    supports_team_drives: Optional[bool] = Query(None, alias='supportsTeamDrives'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/teamdrives',
    description=""" Deprecated use drives.list instead. """,
    tags=['drive_management', 'drive_permission_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_teamdrives_list(
    page_size: Optional[conint(ge=1, le=100)] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    q: Optional[str] = None,
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/teamdrives',
    description=""" Deprecated use drives.create instead. """,
    tags=['team_drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_teamdrives_create(
    request_id: str = Query(..., alias='requestId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TeamDrive = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/teamdrives/{teamDriveId}',
    description=""" Deprecated use drives.delete instead. """,
    tags=['team_drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_teamdrives_delete(
    team_drive_id: str = Path(..., alias='teamDriveId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/teamdrives/{teamDriveId}',
    description=""" Deprecated use drives.get instead. """,
    tags=['team_drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_teamdrives_get(
    team_drive_id: str = Path(..., alias='teamDriveId'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/teamdrives/{teamDriveId}',
    description=""" Deprecated use drives.update instead """,
    tags=['team_drive_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def drive_teamdrives_update(
    team_drive_id: str = Path(..., alias='teamDriveId'),
    use_domain_admin_access: Optional[bool] = Query(None, alias='useDomainAdminAccess'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TeamDrive = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
